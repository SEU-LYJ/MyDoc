* IEEE754浮点数表示
  * 32位浮点数有1位符号位S，8位指数位E（阶码），23位尾数M。
  * (-1)^S^x(1.M)x2^e^
  * e=E - 127
  * 浮点数不能表示真零，以一个极小值表示真0。
    * 1x2^-127^为正0（机器码：0 00000000 000 0000 0000 0000 0000 0000）
    * -1x2^-127^为负0（机器码：1 00000000 000 0000 0000 0000 0000 0000）
    * 阶码E为255且尾数M是0表示无穷，如0 11111111 000 0000 0000 0000 0000 0000表示正无穷
    * 阶码为255且尾数M非0表示NaN(Not a number)
* 花括号初始化变量不允许缩窄，举例：char类型初始化257会报错
* cin在发生错误时，如`cin.getline(buf, size)`比传入的size小，需要调用cin.clear()清空错误标志，然后继续使用
* 枚举对象可以被附一个不属于任何合法枚举值的值;不同的枚举名称可以有相同的枚举值
* 枚举默认4字节，在64位系统上，赋值过大会扩展到8字节，这个实际是由编译器决定的，好的编译器可能会把枚举缩小到1字节
* c++对枚举对象自增会产生编译报错
* 逗号运算符优先级最低，返回值是最后一部分。如`x= (1, 50)`x的值是50
* 把warning设置成报错的好处：入参写反了，类型不匹配会报错；=和==写错了
* 内联函数不能递归
* 宏和内联的差别：宏不能按值传递，如`define test(a) (a) * (a)`，对`test(i++)`会被展开成`(i++) * (i++)`,也就是递增被调用两次。内联只会被调用一次。
* 有些编译器在引用传递参数类型不符合时只会产生警告，这种警告不能忽视，因为不符合时编译器会创建临时变量，不会对入参进行真正的引用
* c++11新增右值引用，自己查一下，不是很重要
* const 传递形参同样会出发构造函数的调用，所以尽量不要用 
* 函数默认参数必须从右向左添加，感悟：这种都是c++设计的友好之处，其实这些能力没有不影响写代码，包括类的默认构造析构，这样可以让c++代码相对c更简洁。
* 模板可以理解为一种预定义好的宏，在模板函数里面可以用typename的各种成员，如果代码中调用的某个实际入参不含这个成员，那么就会在编译阶段报错
* 可以同时定义具体函数，模板函数，显式模板函数，优先级为具体函数大于显式模板函数大于模板函数。参考c++ primer plus第6版第286页
* 显式具体化和显式实例化可以参考p289。基本逻辑是显示显示具体化是不用模板通用函数，显示实例化是仍然使用模板通用函数的。
* decltype用于模板函数中的变量声明，参考p295
* c++ 引用`int test(int x, short y)`等价于`auto test(int x, short y) -> int`的原因是能使得模板函数可以定义自动的返回值(p297头部),如：
``` c++
template<typename T1, typename T2>
auto test(T1 a, T2 b) -> decltype(a + b)
{
  ...
  return a + b;
}
```
因为decltype在参数声明后使用，所以在作用域范围内
* typedef结构体声明不创建变量，而是在源码声